package com.voracious.ep1cG4m3.screens;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Random;

import com.voracious.ep1cG4m3.entities.Player;
import com.voracious.ep1cG4m3.framework.Level;
import com.voracious.ep1cG4m3.framework.Screen;
import com.voracious.ep1cG4m3.framework.Tile;
import com.voracious.ep1cG4m3.tiles.Brick;
import com.voracious.ep1cG4m3.utils.ScreenResultListener;
import com.voracious.ep1cG4m3.utils.Text;

public class Play extends Screen {

	/**
	 * Generated by eclipse
	 */
	private static final long serialVersionUID = -1522258565924156537L;
	public static final double GRAVITY = 1.8;

	public static int currentLevel = 1;
	public static int currentWorld = 1;
	private static int fps = 0;

	private Level level;

	private Player player;
	private Text versionNum;
	private Rectangle viewWindow = new Rectangle(0, 0, 640, 512);

	//Temporary
	//Used in update
	int x = 0;
	int y = 0;
	boolean scroll = false; //Also in start
	//used in start
	private boolean filled = false;

	public Play(ScreenResultListener game, int id) {
		super(game, id);
	}

	@Override
	public void start() {
		player = new Player();
		level = new Level();
		versionNum = new Text("Version 0.1a", new Point(35, 35), 12, 1, Color.BLACK);
		requestFocusInWindow();
		addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent e) {
				player.keyPressed(e);
			}

			public void keyReleased(KeyEvent e) {
				player.keyReleased(e);

				//This is all temporary engine debugging code, which is why it's not in separate methods
				if (e.getKeyCode() == KeyEvent.VK_SPACE) {
					if (scroll)
						scroll = false;
					else
						scroll = true;
				} else if (e.getKeyCode() == KeyEvent.VK_Z) {
					Random rand = new Random();
					level.setTile(new Point(rand.nextInt(level.getWidth()), rand.nextInt(level.getHeight())), Tile.getTile(Brick.name));
				} else if (e.getKeyCode() == KeyEvent.VK_X) {
					Random rand = new Random();
					level.setTile(new Point(rand.nextInt(level.getWidth()), rand.nextInt(level.getHeight())), Tile.getTile("air"));
				} else if (e.getKeyCode() == KeyEvent.VK_C) { //toggles fill level with tiles
					if (!filled) {
						Tile[][] temp = new Tile[level.getWidth()][level.getHeight()];
						for (int r = 0; r < temp.length; r++) {
							for (int c = 0; c < temp[0].length; c++) {
								temp[r][c] = Tile.getTile(Brick.name);
							}
						}
						level.setTiles(temp);
						filled = true;
					}else{
						level.loadNextLevel(); //Doesn't load next level right now, serves as a re-load
					}
				}
			}
		});

	}

	public Player getPlayer() {
		return player;
	}

	public void loadNextLevel() {
		currentLevel++;
		if (currentLevel > 10) {
			currentLevel = 1;
			currentWorld++;
		}
		level.loadNextLevel();
	}

	@Override
	public void update() {
		player.update(System.currentTimeMillis());
		if (scroll) {
			x++;
			y++;
			int xh = (99 * 16) - viewWindow.width;
			int yh = (49 * 16) - viewWindow.height;
			int xx = (int) ((xh / 2) * Math.cos(((2 * Math.PI) / xh) * x) + xh / 2);
			int yy = (int) ((yh / 2) * Math.cos(((2 * Math.PI) / yh) * y) + yh / 2);
			if (xx < 0)
				xx = 0;
			if (yy < 0)
				yy = 0;
			if (yy > yh)
				yy = yh;
			if (xx > xh)
				xx = xh;
			viewWindow.setLocation(xx, yy);
		}
	}

	int[] afps = new int[250];
	int fpsi = 0;

	@Override
	public void draw(Graphics g) {
		Tile[][] tiles = level.getTiles();
		int ri = 0, ci = 0; //Row iterator, column iterator
		int a = viewWindow.x / Tile.tileSize;
		if (a < 0)
			a = 0;

		int b = (viewWindow.width + viewWindow.x) / Tile.tileSize + 1;
		if (b >= tiles.length)
			b = tiles.length - 1;

		int d = viewWindow.y / Tile.tileSize;
		if (d < 0)
			d = 0;
		int e = (viewWindow.height + viewWindow.y) / Tile.tileSize + 1;
		if (e >= tiles[0].length)
			e = tiles[0].length - 1;

		for (int r = a; r < b; r++) {
			for (int c = d; c < e; c++) {
				if (tiles[r][c] != null) {
					int xx = ri * Tile.tileSize - viewWindow.x % Tile.tileSize;
					int yy = ci * Tile.tileSize - viewWindow.y % Tile.tileSize;
					if (!tiles[r][c].getLocation().equals(new Point(xx, yy)))
						tiles[r][c].setLocation(new Point(xx, yy));
					tiles[r][c].paintIcon(this, g);
				}
				ci++;
			}
			ri++;
			ci = 0;
		}

		player.paintIcon(this, g);
		//versionNum.paintIcon(this, g);
		new Text(fps + " fps", new Point(50, 50), 20, 1, Color.BLACK).paintIcon(this, g);
		afps[fpsi] = fps;
		fpsi++;
		if (fpsi >= 250) {
			fpsi = 0;
		}
		int tot = 0;
		int ii = 0;
		for (int i = 0; i < afps.length; i++) {
			if (afps[i] == 0)
				break;
			tot += afps[i];
			ii++;
		}

		new Text("Average fps: " + tot / ii, new Point(50, 80), 20, 1, Color.BLACK).paintIcon(this, g);
	}

	public static void sendFps(int fps) {
		Play.fps = fps;
	}
}

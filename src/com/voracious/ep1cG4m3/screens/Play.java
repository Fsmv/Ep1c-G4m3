package com.voracious.ep1cG4m3.screens;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Random;

import com.voracious.ep1cG4m3.Main;
import com.voracious.ep1cG4m3.entities.Player;
import com.voracious.ep1cG4m3.framework.Level;
import com.voracious.ep1cG4m3.framework.Screen;
import com.voracious.ep1cG4m3.framework.Tile;
import com.voracious.ep1cG4m3.tiles.Brick;
import com.voracious.ep1cG4m3.utils.ScreenResultListener;
import com.voracious.ep1cG4m3.utils.Text;

public class Play extends Screen {

	/**
	 * Generated by eclipse
	 */
	private static final long serialVersionUID = -1522258565924156537L;
	public static final double GRAVITY = 1.8;
	public static final double SCALE = 3;
	
	public static int currentLevel = 1;
	public static int currentWorld = 1;
	private static int fps = 0;				
	int[] afps = new int[250]; //fps history array for computing average
	int fpsi = 0; //fps history array iterator


	private Level level;

	private Player player;
	private Text versionNum;
	private Rectangle viewWindow = new Rectangle(0, 0, 640, 512);

	//Temporary
	//Used in update
	int x = 0;
	int y = 0;
	boolean scroll = false; //Also in start
	//used in start
	private boolean filled = false;

	public Play(ScreenResultListener game, int id) {
		super(game, id);
	}

	@Override
	public void start() {
		player = new Player();
		level = new Level();
		versionNum = new Text("Version 0.1a", new Point(35, 35), 12, 1, Color.BLACK);
		requestFocusInWindow();
		addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent e) {
				player.keyPressed(e);
			}

			public void keyReleased(KeyEvent e) {
				player.keyReleased(e);

				//This is all temporary engine debugging code, which is why it's not in separate methods
				if (e.getKeyCode() == KeyEvent.VK_SPACE) {
					if (scroll)
						scroll = false;
					else
						scroll = true;
				} else if (e.getKeyCode() == KeyEvent.VK_Z) {
					Random rand = new Random();
					level.setTile(new Point(rand.nextInt(level.getWidth()), rand.nextInt(level.getHeight())), Tile.getTile(Brick.name));
				} else if (e.getKeyCode() == KeyEvent.VK_X) {
					Random rand = new Random();
					level.setTile(new Point(rand.nextInt(level.getWidth()), rand.nextInt(level.getHeight())), Tile.getTile("air"));
				} else if (e.getKeyCode() == KeyEvent.VK_C) { //toggles fill level with tiles
					if (!filled) {
						Tile[][] temp = new Tile[level.getWidth()][level.getHeight()];
						for (int r = 0; r < temp.length; r++) {
							for (int c = 0; c < temp[0].length; c++) {
								temp[r][c] = Tile.getTile(Brick.name);
							}
						}
						level.setTiles(temp);
						filled = true;
					}else{
						filled = false;
						level.loadNextLevel(); //Doesn't load next level right now, serves as a re-load
					}
				}
			}
		});

	}

	
	/**
	 * @return the player
	 */
	public Player getPlayer() {
		return player;
	}

	@Override
	public void update() {
		player.update(System.currentTimeMillis());
		if (scroll) {
			x++;
			y++;
			int xh = (int) ((99 * (Tile.tileSize*Play.SCALE)) - viewWindow.width);
			int yh = (int) ((49 * (Tile.tileSize*Play.SCALE)) - viewWindow.height);
			int xx = (int) ((xh / 2) * Math.cos(((2 * Math.PI) / xh) * x) + xh / 2);
			int yy = (int) ((yh / 2) * Math.cos(((2 * Math.PI) / yh) * y) + yh / 2);
			if (xx < 0)
				xx = 0;
			if (yy < 0)
				yy = 0;
			if (yy > yh)
				yy = yh;
			if (xx > xh)
				xx = xh;
			viewWindow.setLocation(xx, yy);
		}
	}

	long [] times = new long[250];
	int timit = 0;
	@Override
	public void draw(Graphics g) {
		Tile[][] tiles = level.getTiles();
		int a = (int) (viewWindow.x / (Tile.tileSize*Play.SCALE));
		if (a < 0)
			a = 0;

		int b = (int) ((viewWindow.width + viewWindow.x) / (Tile.tileSize*Play.SCALE) + 1);
		if (b >= tiles.length)
			b = tiles.length - 1;

		int d = (int) (viewWindow.y / (Tile.tileSize*Play.SCALE));
		if (d < 0)
			d = 0;
		int e = (int) ((viewWindow.height + viewWindow.y) / (Tile.tileSize*Play.SCALE) + 1);
		if (e >= tiles[0].length)
			e = tiles[0].length - 1;

		int it = 0;
		int ri = 0, ci = 0; //Row iterator, column iterator
		for (int r = a; r < b; r++) {
			for (int c = d; c < e; c++) {
				if (tiles[r][c] != null) {
					it++;
					int xx = (int) (ri * (Tile.tileSize*Play.SCALE) - viewWindow.x % (Tile.tileSize*Play.SCALE));
					int yy = (int) (ci * (Tile.tileSize*Play.SCALE) - viewWindow.y % (Tile.tileSize*Play.SCALE));
					if (!tiles[r][c].getLocation().equals(new Point(xx, yy)))
						tiles[r][c].setLocation(new Point(xx, yy));
					long time = System.currentTimeMillis();
					tiles[r][c].paintIcon(this, g);
					times[timit] = System.currentTimeMillis() - time;
					timit++;
					if(timit >= 250)
						timit = 0;
					int temp = 0;
					for(int i=0; i<times.length; i++)
						temp += times[i];
						//System.out.println(temp/(double)  times.length);
				}
				ci++;
			}
			ri++;
			ci = 0;
		}
		//System.out.println(it);

		player.paintIcon(this, g);
		//versionNum.paintIcon(this, g);
		fps = Main.getFps();
		
		new Text(fps + " fps", new Point(50, 50), 20, 1, Color.BLACK).paintIcon(this, g);
		afps[fpsi] = fps;
		fpsi++;
		if (fpsi >= 250) {
			fpsi = 0;
		}
		int tot = 0;
		int ii = 0;
		for (int i = 0; i < afps.length; i++) {
			if (afps[i] == 0)
				break;
			tot += afps[i];
			ii++;
		}
		new Text("Average fps: " + tot / ii, new Point(50, 80), 20, 1, Color.BLACK).paintIcon(this, g);
	}
}